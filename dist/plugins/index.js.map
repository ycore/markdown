{"version":3,"file":"index.js","sources":["../../src/markdown-config.ts","../../src/plugins/plugin-utils.ts","../../src/plugins/markdown-plugin.ts"],"sourcesContent":["// Central configuration for all markdown defaults and asset paths\nexport const MARKDOWN_CONFIG = {\n  EXTENSION: '.md',\n  CHUNK_BY_FOLDER: true,\n  INCREMENTAL_BY_FOLDER: false,\n  PREFIX: 'markdown',\n  PURIFY_HTML: true,\n  UPDATE_DATE: true,\n  COMPRESS: true,\n  CONCURRENCY: {\n    FOLDERS: 5,\n    FILES: 10,\n  },\n  CACHE: {\n    MAX_AGE: 3600, // 1 hour default\n  },\n} as const;\n\n// Central configuration for asset prefixes - change these to modify where markdown assets are stored/fetched\nexport const ASSET_PREFIX = {\n  build: '/assets/docs', // Where assets are written during build (relative to /public)\n  fetch: '/assets/docs', // URL prefix for fetching assets at runtime\n} as const;\n\nexport const ASSET_ROUTES = {\n  docs: (slug: string) => `/markdown/docs/${slug}`,\n  docsApi: (slug: string) => `/markdown/docs/${slug}?api`,\n};\n\n// DOMPurify configuration for markdown content\nexport const DOMPURIFY_CONFIG = {\n  ALLOWED_TAGS: [\n    'h1',\n    'h2',\n    'h3',\n    'h4',\n    'h5',\n    'h6',\n    'p',\n    'br',\n    'strong',\n    'em',\n    'u',\n    's',\n    'del',\n    'a',\n    'img',\n    'ul',\n    'ol',\n    'li',\n    'blockquote',\n    'pre',\n    'code',\n    'table',\n    'thead',\n    'tbody',\n    'tr',\n    'th',\n    'td',\n    'hr',\n    'div',\n    'span',\n  ] as string[],\n  ALLOWED_ATTR: ['href', 'title', 'alt', 'src', 'class', 'id', 'start', 'type', 'colspan', 'rowspan', 'datetime', 'scope', 'data-*'] as string[],\n  FORBID_TAGS: ['script', 'object', 'embed', 'form', 'input', 'button', 'iframe', 'frame', 'frameset', 'noframes'] as string[],\n  FORBID_ATTR: ['style', 'on*'] as string[],\n  KEEP_CONTENT: true,\n  ALLOW_DATA_ATTR: false,\n};\n\n// Shiki highlighter configuration\nexport const HIGHLIGHTER_CONFIG = {\n  LANGS: ['bash', 'css', 'html', 'javascript', 'json', 'markdown', 'sql', 'text', 'ts', 'tsx', 'typescript', 'xml', 'yaml'] as string[],\n  THEMES: ['night-owl'] as string[],\n};\n","import path from 'node:path';\nimport { ASSET_PREFIX } from '../markdown-config';\n\n/**\n * Get the full asset path for files during build time\n * @param filename - The filename to get the path for\n * @param prefix - Optional alternate prefix to use instead of default\n * @returns Full path where the file should be written during build\n */\nexport function getAssetPath(filename: string, prefix?: string): string {\n  // Use provided prefix or fall back to default build prefix\n  const buildPrefix = prefix || ASSET_PREFIX.build;\n  // Normalize the build prefix to handle leading slashes\n  const normalizedPrefix = buildPrefix.startsWith('/') ? buildPrefix.slice(1) : buildPrefix;\n  return path.join(process.cwd(), 'public', normalizedPrefix, filename);\n}\n","/** biome-ignore-all lint/suspicious/noExplicitAny: acceptable */\nimport { existsSync } from 'node:fs';\nimport { mkdir, readdir, readFile, stat, utimes, writeFile } from 'node:fs/promises';\nimport path from 'node:path';\nimport { promisify } from 'node:util';\nimport { gzip } from 'node:zlib';\nimport DOMPurify from 'isomorphic-dompurify';\nimport { marked } from 'marked';\nimport { createHighlighter } from 'shiki';\nimport type { Plugin } from 'vite';\nimport type { FileMetadata, FolderContentChunk, Frontmatter, GlobalManifest, MarkdownBuilderOptions, MarkdownMeta, ProcessingResult, ShikiConfig, SyntaxHighlighter } from '../@types/markdown.types';\nimport { DOMPURIFY_CONFIG, HIGHLIGHTER_CONFIG, MARKDOWN_CONFIG } from '../markdown-config';\nimport { getAssetPath } from './plugin-utils';\n\nconst gzipAsync = promisify(gzip);\n\nexport function markdownBuilder(options: MarkdownBuilderOptions): Plugin {\n  const {\n    source,\n    extension = MARKDOWN_CONFIG.EXTENSION,\n    chunkByFolder = MARKDOWN_CONFIG.CHUNK_BY_FOLDER,\n    incrementalByFolder = MARKDOWN_CONFIG.INCREMENTAL_BY_FOLDER,\n    prefix = MARKDOWN_CONFIG.PREFIX,\n    purifyHtml = MARKDOWN_CONFIG.PURIFY_HTML,\n    shikiConfig,\n    syntaxHighlighter,\n    updateDate = MARKDOWN_CONFIG.UPDATE_DATE,\n    compress = MARKDOWN_CONFIG.COMPRESS,\n  } = options;\n\n  let highlighter: SyntaxHighlighter | null = null;\n  let isInitialized = false;\n\n  async function updateFrontmatterDate(filePath: string, content: string, fileMtime: number): Promise<string> {\n    if (!updateDate) return content;\n\n    const { data: frontmatter, content: markdown } = parseFrontmatter(content);\n    const fileDate = new Date(fileMtime).toISOString().split('T')[0];\n\n    if (!frontmatter || typeof frontmatter !== 'object' || Array.isArray(frontmatter)) return content;\n    if (frontmatter.date === fileDate) return content;\n\n    const updatedFrontmatter = { ...frontmatter, date: fileDate };\n    const frontmatterStr = Object.entries(updatedFrontmatter)\n      .map(([key, value]) => `${key}: ${typeof value === 'string' ? `\"${value}\"` : value}`)\n      .join('\\n');\n\n    const updatedContent = `---\\n${frontmatterStr}\\n---\\n${markdown}`;\n\n    try {\n      await writeFile(filePath, updatedContent);\n\n      // Restore original timestamp to preserve manual edit time\n      const originalDate = new Date(fileMtime);\n      await utimes(filePath, originalDate, originalDate);\n\n      console.info(`üìÖ Updated frontmatter date in ${filePath} to match file`);\n      return updatedContent;\n    } catch (error) {\n      console.warn(`‚ö†Ô∏è Failed to update date in ${filePath}:`, error);\n      return content;\n    }\n  }\n\n  // Initialize highlighter and marked configuration\n  async function initializeHighlighter(): Promise<void> {\n    if (isInitialized) return;\n\n    if (syntaxHighlighter === null) {\n      highlighter = null;\n    } else if (syntaxHighlighter) {\n      highlighter = syntaxHighlighter;\n    } else {\n      try {\n        highlighter = await createShikiHighlighter(shikiConfig);\n      } catch (error) {\n        console.warn('‚ö†Ô∏è Failed to initialize Shiki highlighter:', error);\n        highlighter = null;\n      }\n    }\n\n    isInitialized = true;\n  }\n\n  async function collectMarkdownFilesWithMetadata(dir: string): Promise<Map<string, { path: string; metadata: FileMetadata }>> {\n    const result = new Map();\n\n    async function walk(current: string) {\n      const entries = await readdir(current, { withFileTypes: true });\n      await Promise.all(\n        entries.map(async entry => {\n          const full = path.join(current, entry.name);\n          if (entry.isDirectory()) return walk(full);\n          if (!entry.name.endsWith(extension)) return;\n          const stats = await stat(full);\n          const rel = path.relative(dir, full);\n          result.set(rel, { path: full, metadata: { mtime: stats.mtime.getTime(), size: stats.size } });\n        })\n      );\n    }\n\n    await walk(dir);\n    return result;\n  }\n\n  async function collectFilesByFolder(dir: string): Promise<Map<string, Map<string, { path: string; metadata: FileMetadata }>>> {\n    const folderMap = new Map();\n    const files = await collectMarkdownFilesWithMetadata(dir);\n\n    for (const [relPath, fileInfo] of files) {\n      const folder = path.dirname(relPath) === '.' ? 'root' : path.dirname(relPath);\n      if (!folderMap.has(folder)) {\n        folderMap.set(folder, new Map());\n      }\n      folderMap.get(folder)?.set(relPath, fileInfo);\n    }\n\n    return folderMap;\n  }\n\n  function isFileChanged(prev: MarkdownMeta | undefined, current: FileMetadata): boolean {\n    return !prev || prev._mtime !== current.mtime || prev._size !== current.size;\n  }\n\n  async function checkForChanges(dir: string, previous: MarkdownMeta[]) {\n    const previousMap = new Map(previous.map(entry => [entry.path, entry]));\n    const currentFiles = await collectMarkdownFilesWithMetadata(dir);\n\n    for (const [relPath, { metadata }] of currentFiles) {\n      if (isFileChanged(previousMap.get(relPath), metadata)) {\n        return { changed: true, updatedFiles: currentFiles };\n      }\n    }\n\n    if (previous.length !== currentFiles.size) {\n      return { changed: true, updatedFiles: currentFiles };\n    }\n\n    return { changed: false, updatedFiles: currentFiles };\n  }\n\n  async function checkForFolderChanges(dir: string): Promise<{ changedFolders: Set<string>; allFolders: Map<string, Map<string, { path: string; metadata: FileMetadata }>> }> {\n    const allFolders = await collectFilesByFolder(dir);\n    const changedFolders = new Set<string>();\n\n    if (!incrementalByFolder) {\n      // If not incremental, mark all folders as changed\n      for (const folder of allFolders.keys()) {\n        changedFolders.add(folder);\n      }\n      return { changedFolders, allFolders };\n    }\n\n    // Load previous global manifest and check for folder changes\n    const prevGlobalManifest = await loadPreviousManifest();\n    const prevFilesByFolder = new Map<string, Map<string, MarkdownMeta>>();\n\n    // Group previous files by folder\n    for (const meta of prevGlobalManifest) {\n      const folder = meta.folder || 'root';\n      if (!prevFilesByFolder.has(folder)) {\n        prevFilesByFolder.set(folder, new Map());\n      }\n      prevFilesByFolder.get(folder)?.set(meta.path, meta);\n    }\n\n    // Check each current folder against previous state\n    for (const [folder, files] of allFolders) {\n      const prevFiles = prevFilesByFolder.get(folder);\n\n      if (!prevFiles) {\n        // New folder\n        changedFolders.add(folder);\n        continue;\n      }\n\n      // Check if any files in this folder have changed\n      let folderChanged = false;\n      for (const [relPath, { metadata }] of files) {\n        const prevFile = prevFiles.get(relPath);\n        if (isFileChanged(prevFile, metadata)) {\n          folderChanged = true;\n          break;\n        }\n      }\n\n      // Check if file count changed\n      if (!folderChanged && prevFiles.size !== files.size) {\n        folderChanged = true;\n      }\n\n      if (folderChanged) {\n        changedFolders.add(folder);\n      }\n    }\n\n    return { changedFolders, allFolders };\n  }\n\n  async function processChangedFiles(files: Map<string, { path: string; metadata: FileMetadata }>): Promise<ProcessingResult> {\n    await initializeHighlighter();\n\n    const manifest: MarkdownMeta[] = [];\n    const content: Record<string, any> = {};\n    let errorCount = 0;\n\n    const entries = [...files.entries()];\n\n    await execConcurrently(entries, MARKDOWN_CONFIG.CONCURRENCY.FILES, async ([relPath, { path: filePath, metadata }]) => {\n      try {\n        const raw = await readFile(filePath, 'utf8');\n        const updated = await updateFrontmatterDate(filePath, raw, metadata.mtime);\n        const { data: frontmatter } = parseFrontmatter(updated);\n        const { content: html, error, errorContext } = await processMarkdownFile(filePath, purifyHtml, highlighter);\n\n        if (error) {\n          const errorMessage = errorContext ? `${error}\\n  File: ${filePath}\\n  ${errorContext}` : `${error}\\n  File: ${filePath}`;\n          throw new Error(errorMessage);\n        }\n\n        const slug = relPath.replace(new RegExp(`${extension}$`), '');\n        const folder = path.dirname(relPath) === '.' ? undefined : path.dirname(relPath);\n\n        const validFrontmatter = (frontmatter as Frontmatter) || {};\n        manifest.push({ slug, path: relPath, folder, _mtime: metadata.mtime, _size: metadata.size, ...validFrontmatter });\n        content[slug] = { frontmatter: validFrontmatter, content: html };\n      } catch (e) {\n        errorCount++;\n        console.error(`‚ùå Error processing ${filePath}:`, e);\n      }\n    });\n\n    return { manifest: sortManifest(manifest), content, processedCount: manifest.length, errorCount };\n  }\n\n  async function processFolderFiles(folderFiles: Map<string, { path: string; metadata: FileMetadata }>): Promise<{ manifest: MarkdownMeta[]; content: FolderContentChunk; errorCount: number }> {\n    await initializeHighlighter();\n\n    const manifest: MarkdownMeta[] = [];\n    const content: FolderContentChunk = {};\n    let errorCount = 0;\n\n    const entries = [...folderFiles.entries()];\n\n    await execConcurrently(entries, MARKDOWN_CONFIG.CONCURRENCY.FILES, async ([relPath, { path: filePath, metadata }]) => {\n      try {\n        const raw = await readFile(filePath, 'utf8');\n        const updated = await updateFrontmatterDate(filePath, raw, metadata.mtime);\n        const { data: frontmatter } = parseFrontmatter(updated);\n        const { content: html, error, errorContext } = await processMarkdownFile(filePath, purifyHtml, highlighter);\n\n        if (error) {\n          const errorMessage = errorContext ? `${error}\\n  File: ${filePath}\\n  ${errorContext}` : `${error}\\n  File: ${filePath}`;\n          throw new Error(errorMessage);\n        }\n\n        const slug = relPath.replace(new RegExp(`${extension}$`), '');\n        const folder = path.dirname(relPath) === '.' ? undefined : path.dirname(relPath);\n\n        const validFrontmatter = (frontmatter as Frontmatter) || {};\n        manifest.push({ slug, path: relPath, folder, _mtime: metadata.mtime, _size: metadata.size, ...validFrontmatter });\n        content[slug] = { frontmatter: validFrontmatter, content: html };\n      } catch (e) {\n        errorCount++;\n        console.error(`‚ùå Error processing ${filePath}:`, e);\n      }\n    });\n\n    return { manifest: sortManifest(manifest), content, errorCount };\n  }\n\n  async function processChangedFolders(changedFolders: Set<string>, allFolders: Map<string, Map<string, { path: string; metadata: FileMetadata }>>) {\n    await initializeHighlighter();\n\n    const globalManifest: MarkdownMeta[] = [];\n    let totalProcessed = 0;\n    let totalErrors = 0;\n\n    // Process folders in parallel with limited concurrency\n    // biome-ignore lint/style/noNonNullAssertion: satisfactory\n    const folderEntries = Array.from(changedFolders).map(folder => ({ folder, files: allFolders.get(folder)! }));\n\n    await execConcurrently(folderEntries, MARKDOWN_CONFIG.CONCURRENCY.FOLDERS, async ({ folder, files }) => {\n      try {\n        console.info(`üìÇ Processing folder: ${folder} (${files.size} files)`);\n        const result = await processFolderFiles(files);\n\n        // Write folder-specific files\n        await writeFolderFiles(folder, result.manifest, result.content);\n\n        // Add to global manifest\n        globalManifest.push(...result.manifest);\n        totalProcessed += result.manifest.length;\n        totalErrors += result.errorCount;\n\n        console.info(`‚úÖ Completed folder: ${folder} (${result.manifest.length} files)`);\n      } catch (error) {\n        console.error(`‚ùå Error processing folder ${folder}:`, error);\n        totalErrors++;\n      }\n    });\n\n    return { manifest: sortManifest(globalManifest), processedCount: totalProcessed, errorCount: totalErrors };\n  }\n\n  async function loadPreviousManifest(): Promise<MarkdownMeta[]> {\n    try {\n      const file = getAssetPath(`${prefix}-manifest.json`);\n      if (!existsSync(file)) return [];\n\n      const globalManifest = JSON.parse(await readFile(file, 'utf8')) as GlobalManifest;\n      return globalManifest.documents || [];\n    } catch {\n      return [];\n    }\n  }\n\n  // Helper to write compressed versions of JSON files\n  async function writeCompressedVersions(filename: string, content: string) {\n    if (!compress) {\n      return;\n    }\n\n    try {\n      const buffer = Buffer.from(content, 'utf8');\n      const compressedBuffer = await gzipAsync(buffer);\n      const compressedPath = getAssetPath(`${filename}.gz`);\n      await writeFile(compressedPath, compressedBuffer);\n\n      const ratio = ((1 - compressedBuffer.length / content.length) * 100).toFixed(1);\n      console.info(`  üì¶ ${filename}.gz: ${compressedBuffer.length} bytes compressed ${ratio}%`);\n    } catch (error) {\n      console.warn(`Failed to write compressed version of ${filename}:`, error);\n    }\n  }\n\n  // Function to write JSON files with optional compression\n  async function writeMarkdownFiles(manifest: MarkdownMeta[], content: Record<string, any>, chunkedFolders?: string[]) {\n    try {\n      const dir = path.dirname(getAssetPath('dummy'));\n      await mkdir(dir, { recursive: true });\n\n      // Create global manifest with chunking metadata\n      const globalManifest: GlobalManifest = {\n        documents: manifest,\n        _buildMode: chunkByFolder ? 'chunked' : 'single',\n        ...(chunkByFolder && chunkedFolders && { chunkedFolders }),\n      };\n\n      // Write manifest (always uncompressed - small file, frequently accessed)\n      const manifestContent = JSON.stringify(globalManifest, null, 2);\n      await writeFile(getAssetPath(`${prefix}-manifest.json`), manifestContent);\n\n      // Write content if not chunked\n      if (!chunkByFolder && Object.keys(content).length > 0) {\n        const contentJson = JSON.stringify(content, null, 2);\n\n        if (compress) {\n          // Only write compressed version for content files\n          await writeCompressedVersions(`${prefix}-content.json`, contentJson);\n        } else {\n          // Write uncompressed version if compression is disabled\n          await writeFile(getAssetPath(`${prefix}-content.json`), contentJson);\n        }\n      }\n    } catch (e) {\n      console.error('‚ùå Failed to write markdown JSON files:', e);\n    }\n  }\n\n  async function writeFolderFiles(folder: string, _manifest: MarkdownMeta[], content: FolderContentChunk) {\n    try {\n      const dir = path.dirname(getAssetPath('dummy'));\n      await mkdir(dir, { recursive: true });\n\n      const folderKey = folder.replace(/[/\\\\]/g, '-');\n      const filename = `${prefix}-content-${folderKey}.json`;\n\n      // Write folder content chunk only - manifest contains all metadata\n      const contentJson = JSON.stringify(content, null, 2);\n\n      if (compress) {\n        // Only write compressed version for content files\n        await writeCompressedVersions(filename, contentJson);\n      } else {\n        // Write uncompressed version if compression is disabled\n        await writeFile(getAssetPath(filename), contentJson);\n      }\n    } catch (e) {\n      console.error(`‚ùå Failed to write folder files for ${folder}:`, e);\n    }\n  }\n\n  return {\n    name: 'markdown-builder',\n    async buildStart() {\n      const docsDir = path.join(process.cwd(), source);\n\n      // Check if source directory exists, skip if not\n      try {\n        await stat(docsDir);\n      } catch {\n        console.info(`üìÑ Source directory '${source}' does not exist, skipping markdown build`);\n        return;\n      }\n\n      if (chunkByFolder) {\n        const { changedFolders, allFolders } = await checkForFolderChanges(docsDir);\n\n        if (changedFolders.size === 0) {\n          console.info('üìÑ No folder changes detected, skipping build');\n          return;\n        }\n\n        console.info(`üìÇ Processing ${changedFolders.size} changed folders out of ${allFolders.size} total`);\n        const result = await processChangedFolders(changedFolders, allFolders);\n        const folderList = Array.from(allFolders.keys());\n        await writeMarkdownFiles(result.manifest, {}, folderList);\n        console.info(`  üìÑ Processed ${result.processedCount} files with ${result.errorCount} errors`);\n      } else {\n        const prev = await loadPreviousManifest();\n        const { changed, updatedFiles } = await checkForChanges(docsDir, prev);\n        if (!changed) return;\n        const result = await processChangedFiles(updatedFiles);\n        await writeMarkdownFiles(result.manifest, result.content);\n        console.info(`  üìÑ Processing ${updatedFiles.size} updated markdown files from: ${source}`);\n      }\n    },\n    async handleHotUpdate({ file, server }) {\n      if (file.includes(source) && file.endsWith(extension)) {\n        const docsDir = path.join(process.cwd(), source);\n\n        if (chunkByFolder) {\n          // Determine which folder changed and only rebuild that folder\n          const relativePath = path.relative(path.join(process.cwd(), source), file);\n          const folder = path.dirname(relativePath) === '.' ? 'root' : path.dirname(relativePath);\n\n          const allFolders = await collectFilesByFolder(docsDir);\n          const changedFolders = new Set([folder]);\n\n          const result = await processChangedFolders(changedFolders, allFolders);\n\n          // Update global manifest\n          const globalManifest = await loadPreviousManifest();\n          const updatedManifest = globalManifest.filter(item => item.folder !== folder);\n          updatedManifest.push(...result.manifest);\n\n          const allFoldersForHotReload = await collectFilesByFolder(docsDir);\n          const folderList = Array.from(allFoldersForHotReload.keys());\n          await writeMarkdownFiles(sortManifest(updatedManifest), {}, folderList);\n          console.info(`üîÑ Hot updated folder: ${folder}`);\n        } else {\n          const files = await collectMarkdownFilesWithMetadata(docsDir);\n          const result = await processChangedFiles(files);\n          await writeMarkdownFiles(result.manifest, result.content);\n        }\n\n        server.ws.send({ type: 'full-reload' });\n      }\n    },\n  };\n}\n\n// Simple frontmatter parser (no dependencies)\nfunction parseFrontmatter(content: string) {\n  const match = content.match(/^---\\s*\\n(.*?)\\n---\\s*\\n(.*)$/s);\n  if (!match) {\n    return { data: {}, content };\n  }\n\n  const [, frontmatterText, markdown] = match;\n  const frontmatter: Frontmatter = {};\n\n  if (!frontmatterText) return frontmatter;\n\n  // Simple YAML parser for basic key-value pairs\n  const lines = frontmatterText.split('\\n').filter(line => line.trim());\n  for (const line of lines) {\n    const colonIndex = line.indexOf(':');\n    if (colonIndex > 0) {\n      const key = line.substring(0, colonIndex).trim();\n      const value = line.substring(colonIndex + 1).trim();\n\n      // Remove quotes if present\n      const cleanValue = value.replace(/^['\"]|['\"]$/g, '');\n\n      // Try to parse as date\n      if (key === 'date' && cleanValue.match(/^\\d{4}-\\d{2}-\\d{2}$/)) {\n        frontmatter[key] = new Date(cleanValue).toISOString().split('T')[0];\n      } else {\n        frontmatter[key] = cleanValue;\n      }\n    }\n  }\n\n  return { data: frontmatter, content: markdown };\n}\n\nasync function processMarkdownFile(filePath: string, purifyHtml = true, highlighter?: SyntaxHighlighter | null): Promise<{ content: string; error?: string; errorContext?: string }> {\n  try {\n    const source = await readFile(filePath, 'utf8');\n    const { content: markdown } = parseFrontmatter(source);\n    const markdownString = typeof markdown === 'string' ? markdown : String(markdown || '');\n    const htmlContent = marked.parse(markdownString, { breaks: true, gfm: true });\n\n    if (typeof htmlContent !== 'string') {\n      return { content: markdownString, error: `Unexpected marked result type: ${typeof htmlContent}` };\n    }\n\n    const sanitizedContent = purifyHtml ? DOMPurify.sanitize(htmlContent, DOMPURIFY_CONFIG) : htmlContent;\n    const result = highlighter ? await highlightCodeBlocks(htmlContent, highlighter, filePath) : { content: sanitizedContent };\n\n    if ('error' in result) {\n      return { content: '', error: result.error, errorContext: result.errorContext };\n    }\n\n    return { content: result.content };\n  } catch (error) {\n    return {\n      content: '',\n      error: error instanceof Error ? error.message : String(error),\n    };\n  }\n}\n\nfunction sortManifest(manifest: MarkdownMeta[]): MarkdownMeta[] {\n  return manifest.sort((a, b) => {\n    // Sort by folder first\n    const folderA = a.folder || '';\n    const folderB = b.folder || '';\n\n    if (folderA !== folderB) {\n      return folderA.localeCompare(folderB);\n    }\n\n    // Within same folder, sort by date (newest first)\n    if (a.date && b.date) {\n      return new Date(b.date).getTime() - new Date(a.date).getTime();\n    }\n\n    // Then by title\n    if (a.title && b.title) {\n      return a.title.localeCompare(b.title);\n    }\n\n    // Finally by slug to ensure deterministic ordering\n    return a.slug.localeCompare(b.slug);\n  });\n}\n\n// Create default Shiki highlighter\nasync function createShikiHighlighter(config: ShikiConfig = {}): Promise<SyntaxHighlighter> {\n  const { langs = [...HIGHLIGHTER_CONFIG.LANGS], themes = [...HIGHLIGHTER_CONFIG.THEMES] } = config;\n  const highlighter = await createHighlighter({ langs, themes });\n\n  return {\n    highlight: (code: string, language: string) => {\n      try {\n        const html = highlighter.codeToHtml(code, { lang: language, theme: 'night-owl', colorReplacements: { '#011627': '#1f2937' } });\n        // Add mobile-responsive classes to the generated pre element\n        return html.replace(/<pre[^>]*>/, '<pre class=\"overflow-x-auto text-xs md:text-sm\" style=\"background-color: #1f2937 !important;\">');\n      } catch (error) {\n        // Provide helpful error message for missing languages\n        if (error instanceof Error && error.message.includes('not found')) {\n          throw new Error(`Language \\`${language}\\` not found in Shiki highlighter`);\n        }\n        throw error;\n      }\n    },\n  };\n}\n\nasync function highlightCodeBlocks(htmlContent: string, highlighter: SyntaxHighlighter, filePath?: string): Promise<{ content: string } | { error: string; errorContext?: string }> {\n  // Regular expression to find code blocks: <pre><code class=\"language-xxx\">content</code></pre>\n  const codeBlockRegex = /<pre><code(?:\\s+class=\"language-([^\"]*)\")?>([\\s\\S]*?)<\\/code><\\/pre>/g;\n\n  let processedContent = htmlContent;\n  const matches = [...htmlContent.matchAll(codeBlockRegex)];\n\n  for (const match of matches) {\n    const [fullMatch, language, codeContent] = match;\n\n    if (!codeContent) continue;\n\n    // Decode HTML entities in the code content\n    const decodedContent = codeContent\n      .replace(/&lt;/g, '<')\n      .replace(/&gt;/g, '>')\n      .replace(/&amp;/g, '&')\n      .replace(/&quot;/g, '\"')\n      .replace(/&#39;/g, \"'\");\n\n    try {\n      const highlightedContent = await highlighter.highlight(decodedContent, language || 'text');\n      processedContent = processedContent.replace(fullMatch, highlightedContent);\n    } catch (error) {\n      // Extract a snippet of the code for context (first 100 chars)\n      const codeSnippet = decodedContent.substring(0, 100).replace(/\\n/g, '\\\\n');\n      const errorContext = `Language: \\`${language || 'text'}\\`\\n  Code snippet: \"${codeSnippet}${decodedContent.length > 100 ? '...' : ''}\"`;\n\n      console.error('\\n‚ùå Markdown Processing Error:');\n      console.error(`  File: ${filePath || 'unknown'}`);\n      console.error(`  ${errorContext}`);\n      console.error(`  Error: ${error instanceof Error ? error.message : String(error)}`);\n      console.error(`\\n  üí° Solution: Add '${language}' to HIGHLIGHTER_CONFIG.LANGS in markdown-config.ts\\n`);\n\n      // Return error with context instead of continuing\n      return {\n        error: `Failed to highlight code block with language \"${language}\"`,\n        errorContext,\n      };\n    }\n  }\n\n  return { content: processedContent };\n}\n\nasync function execConcurrently<T>(items: T[], limit: number, handler: (item: T) => Promise<void>): Promise<void> {\n  const executing: Promise<void>[] = [];\n\n  for (const item of items) {\n    const p = handler(item);\n    executing.push(p);\n\n    if (executing.length >= limit) {\n      await Promise.race(executing).catch(() => {});\n      for (let i = executing.length - 1; i >= 0; i--) {\n        try {\n          await executing[i];\n          executing.splice(i, 1);\n        } catch {\n          executing.splice(i, 1);\n        }\n      }\n    }\n  }\n\n  await Promise.allSettled(executing);\n}\n"],"names":[],"mappings":"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"}