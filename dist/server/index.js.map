{"version":3,"file":"index.js","sources":["../../src/markdown-config.ts","../../src/markdown-utils.ts","../../src/markdown-data.ts","../../src/server/markdown.server.ts"],"sourcesContent":["// Central configuration for all markdown defaults and asset paths\nexport const MARKDOWN_CONFIG = {\n  EXTENSION: '.md',\n  CHUNK_BY_FOLDER: true,\n  INCREMENTAL_BY_FOLDER: false,\n  PREFIX: 'markdown',\n  PURIFY_HTML: true,\n  UPDATE_DATE: true,\n  COMPRESS: true,\n  CONCURRENCY: {\n    FOLDERS: 5,\n    FILES: 10,\n  },\n  CACHE: {\n    MAX_AGE: 3600, // 1 hour default\n  },\n} as const;\n\n// Central configuration for asset prefixes - change these to modify where markdown assets are stored/fetched\nexport const ASSET_PREFIX = {\n  build: '/assets/docs', // Where assets are written during build (relative to /public)\n  fetch: '/assets/docs', // URL prefix for fetching assets at runtime\n} as const;\n\nexport const ASSET_ROUTES = {\n  docs: (slug: string) => `/markdown/docs/${slug}`,\n  docsApi: (slug: string) => `/markdown/docs/${slug}?api`,\n};\n\n// DOMPurify configuration for markdown content\nexport const DOMPURIFY_CONFIG = {\n  ALLOWED_TAGS: [\n    'h1',\n    'h2',\n    'h3',\n    'h4',\n    'h5',\n    'h6',\n    'p',\n    'br',\n    'strong',\n    'em',\n    'u',\n    's',\n    'del',\n    'a',\n    'img',\n    'ul',\n    'ol',\n    'li',\n    'blockquote',\n    'pre',\n    'code',\n    'table',\n    'thead',\n    'tbody',\n    'tr',\n    'th',\n    'td',\n    'hr',\n    'div',\n    'span',\n  ] as string[],\n  ALLOWED_ATTR: ['href', 'title', 'alt', 'src', 'class', 'id', 'start', 'type', 'colspan', 'rowspan', 'datetime', 'scope', 'data-*'] as string[],\n  FORBID_TAGS: ['script', 'object', 'embed', 'form', 'input', 'button', 'iframe', 'frame', 'frameset', 'noframes'] as string[],\n  FORBID_ATTR: ['style', 'on*'] as string[],\n  KEEP_CONTENT: true,\n  ALLOW_DATA_ATTR: false,\n};\n\n// Shiki highlighter configuration\nexport const HIGHLIGHTER_CONFIG = {\n  LANGS: ['bash', 'css', 'html', 'javascript', 'json', 'markdown', 'sql', 'text', 'ts', 'tsx', 'typescript', 'xml', 'yaml'] as string[],\n  THEMES: ['night-owl'] as string[],\n};\n","import * as v from 'valibot';\nimport { ASSET_PREFIX } from './markdown-config';\n\n/**\n * Schema for validating document slugs\n * Allows: letters, numbers, hyphens, underscores, and forward slashes\n * Prevents: directory traversal attempts, leading/trailing slashes\n */\nconst documentSlugSchema = v.pipe(\n  v.string(),\n  v.trim(),\n  v.minLength(1, 'Slug cannot be empty'),\n  v.regex(/^[a-zA-Z0-9-_/]+$/, 'Slug can only contain letters, numbers, hyphens, underscores, and forward slashes'),\n  v.check(slug => !slug.includes('..'), 'Directory traversal not allowed'),\n  v.check(slug => !slug.startsWith('/'), 'Slug cannot start with forward slash'),\n  v.check(slug => !slug.endsWith('/'), 'Slug cannot end with forward slash')\n);\n\n/**\n * Validates and sanitizes a document slug\n * @param slug - The slug to validate\n * @returns Validated slug\n * @throws Response with 400 status if validation fails\n */\nexport function validateDocumentSlug(slug: unknown): string {\n  try {\n    return v.parse(documentSlugSchema, slug);\n  } catch (error) {\n    if (error instanceof v.ValiError) {\n      const message = error.issues[0]?.message || 'Invalid document url';\n      throw new Response(message, { status: 400 });\n    }\n    throw new Response('Invalid document slug', { status: 400 });\n  }\n}\n\n/**\n * Format the asset URL for fetching at runtime\n * @param filename - The filename to get the URL for\n * @param request - Optional request object for absolute URL generation\n * @param prefix - Optional alternate prefix to use instead of default\n * @returns Base URL where the file can be fetched at runtime (fetchContent will handle .gz fallback)\n */\nexport function formatAssetUrl(filename: string, request?: Request, prefix?: string): string {\n  // Use provided prefix or fall back to default fetch prefix\n  const fetchPrefix = prefix || ASSET_PREFIX.fetch;\n  const normalizedPrefix = fetchPrefix.endsWith('/') ? fetchPrefix.slice(0, -1) : fetchPrefix;\n  const url = `${normalizedPrefix}/${filename}`;\n  return request ? new URL(url, request.url).href : url;\n}\n","import type { Fetcher, GlobalManifest, MarkdownContent, MarkdownMeta } from './@types/markdown.types';\nimport { MARKDOWN_CONFIG } from './markdown-config';\nimport { formatAssetUrl } from './markdown-utils';\n\n// ============================================================================\n// CACHE MANAGEMENT\n// ============================================================================\n\n// In-memory caches for loaded data to avoid multiple file reads\nlet manifestCache: MarkdownMeta[] | null = null;\nlet globalManifestCache: GlobalManifest | null = null;\nlet contentCache: Record<string, MarkdownContent> | null = null;\nconst folderContentCache: Map<string, Record<string, MarkdownContent>> = new Map();\n\n// ============================================================================\n// CORE DATA FETCHING\n// ============================================================================\n\n/**\n * Fetch JSON content with smart compression fallback\n * @param url - The URL to fetch from (should be the base .json URL)\n * @param assets - Cloudflare ASSETS binding for static asset serving\n * @returns Parsed JSON content\n */\nasync function fetchContent<T>(url: string, assets: Fetcher): Promise<T> {\n  // Use ASSETS binding for internal asset fetching\n  const fetchFn = (input: RequestInfo | URL, init?: RequestInit) => assets.fetch(input, init);\n\n  // Determine URLs for both compressed and uncompressed versions\n  const baseUrl = url.endsWith('.gz') ? url.replace('.gz', '') : url;\n  const gzUrl = `${baseUrl}.gz`;\n\n  // Try compressed version first\n  try {\n    const gzResponse = await fetchFn(gzUrl);\n\n    if (gzResponse.ok) {\n      // Decompress using Web Streams API\n      const compressedData = await gzResponse.arrayBuffer();\n      const decompressedStream = new DecompressionStream('gzip');\n      const decompressedResponse = new Response(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue(new Uint8Array(compressedData));\n            controller.close();\n          },\n        }).pipeThrough(decompressedStream)\n      );\n\n      const decompressedText = await decompressedResponse.text();\n      const parsed = JSON.parse(decompressedText) as T;\n      return parsed;\n    }\n  } catch (_compressionError) {\n    // Compression attempt failed, fall back to uncompressed\n  }\n\n  // Fallback to uncompressed version\n  try {\n    const response = await fetchFn(baseUrl);\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    const parsed = (await response.json()) as T;\n    return parsed;\n  } catch (uncompressedError) {\n    const errorMsg = `Failed to fetch both compressed (${gzUrl}) and uncompressed (${baseUrl}) versions: ${uncompressedError instanceof Error ? uncompressedError.message : 'Unknown error'}`;\n    throw new Error(errorMsg);\n  }\n}\n\n// ============================================================================\n// MANIFEST FUNCTIONS\n// ============================================================================\n\n/**\n * Get global manifest data which includes documents and chunking info\n */\nasync function getGlobalManifest(assets: Fetcher, request?: Request, prefix?: string): Promise<GlobalManifest> {\n  if (globalManifestCache) {\n    return globalManifestCache;\n  }\n\n  try {\n    const manifestUrl = formatAssetUrl(`${prefix || MARKDOWN_CONFIG.PREFIX}-manifest.json`, request);\n    const globalManifest = await fetchContent<GlobalManifest>(manifestUrl, assets);\n    globalManifestCache = globalManifest;\n    return globalManifest;\n  } catch (_error) {\n    return { documents: [], _buildMode: 'single' };\n  }\n}\n\n/**\n * Get markdown manifest data from generated JSON file\n * This reads from the consumer app's generated manifest file\n */\nexport async function getMarkdownManifest(assets: Fetcher, request?: Request, prefix?: string): Promise<MarkdownMeta[]> {\n  if (manifestCache) {\n    return manifestCache;\n  }\n\n  const globalManifest = await getGlobalManifest(assets, request, prefix);\n\n  // Filter out build metadata for runtime use\n  const cleanManifest = globalManifest.documents.map(({ _mtime, _size, ...item }) => item);\n\n  manifestCache = cleanManifest;\n  return cleanManifest;\n}\n\n// ============================================================================\n// CONTENT FUNCTIONS\n// ============================================================================\n\n/**\n * Get markdown content data from generated JSON file\n * This reads from the consumer app's generated content file or folder chunks\n */\nexport async function getMarkdownContent(assets: Fetcher, request?: Request, prefix?: string): Promise<Record<string, MarkdownContent>> {\n  const globalManifest = await getGlobalManifest(assets, request, prefix);\n\n  // In folder chunk mode, we don't preload all content\n  if (globalManifest._buildMode === 'chunked') {\n    return {};\n  }\n\n  if (contentCache) {\n    return contentCache;\n  }\n\n  try {\n    const contentUrl = formatAssetUrl(`${prefix || MARKDOWN_CONFIG.PREFIX}-content.json`, request);\n    const content = await fetchContent<Record<string, MarkdownContent>>(contentUrl, assets);\n    contentCache = content;\n    return content;\n  } catch (_error) {\n    return {};\n  }\n}\n\n/**\n * Load content for a specific folder (lazy loading)\n */\nasync function loadFolderContent(folder: string, assets: Fetcher, request?: Request, prefix?: string): Promise<Record<string, MarkdownContent>> {\n  // Check cache first\n  if (folderContentCache.has(folder)) {\n    const cachedContent = folderContentCache.get(folder);\n    if (cachedContent) {\n      return cachedContent;\n    }\n  }\n\n  try {\n    const folderKey = folder.replace(/[/\\\\]/g, '-');\n    const contentUrl = formatAssetUrl(`${prefix || MARKDOWN_CONFIG.PREFIX}-content-${folderKey}.json`, request);\n\n    const content = await fetchContent<Record<string, MarkdownContent>>(contentUrl, assets);\n    folderContentCache.set(folder, content);\n    return content;\n  } catch (_error) {\n    return {};\n  }\n}\n\n/**\n * Get a specific markdown document by slug\n */\nexport async function getMarkdownDocument(slug: string, assets: Fetcher, request?: Request, prefix?: string): Promise<MarkdownContent | null> {\n  const globalManifest = await getGlobalManifest(assets, request, prefix);\n\n  // In folder chunk mode, we need to determine which folder the document is in\n  if (globalManifest._buildMode === 'chunked') {\n    const manifest = await getMarkdownManifest(assets, request, prefix);\n    const docMeta = manifest.find(doc => doc.slug === slug);\n\n    if (!docMeta) {\n      return null;\n    }\n\n    // Documents without a folder are in the root folder\n    const folder = docMeta.folder || 'root';\n    const folderContent = await loadFolderContent(folder, assets, request, prefix);\n    return folderContent[slug] || null;\n  }\n\n  // Fallback to traditional mode\n  const content = await getMarkdownContent(assets, request, prefix);\n  return content[slug] || null;\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Clear the cache (useful for testing or hot reload)\n */\nexport function clearMarkdownCache(): void {\n  manifestCache = null;\n  globalManifestCache = null;\n  contentCache = null;\n  folderContentCache.clear();\n}\n\n/**\n * Check if a document exists by slug\n */\nexport async function hasMarkdownDocument(slug: string, assets: Fetcher, request?: Request, prefix?: string): Promise<boolean> {\n  const globalManifest = await getGlobalManifest(assets, request, prefix);\n\n  if (globalManifest._buildMode === 'chunked') {\n    const manifest = await getMarkdownManifest(assets, request, prefix);\n    return manifest.some(doc => doc.slug === slug);\n  }\n\n  const content = await getMarkdownContent(assets, request, prefix);\n  return slug in content;\n}\n","import type { Fetcher } from '../@types/markdown.types';\nimport { getMarkdownDocument, getMarkdownManifest } from '../markdown-data';\n\nexport async function markdownLoader({ request, ASSETS }: { request: Request; ASSETS: Fetcher }) {\n  try {\n    const manifest = await getMarkdownManifest(ASSETS, request);\n    return manifest;\n  } catch (_error) {\n    return [];\n  }\n}\n\nexport async function markdownSlugLoader({ validatedSlug, request, ASSETS }: { validatedSlug: string; request: Request; ASSETS: Fetcher }) {\n  const url = new URL(request.url);\n  const isApiCall = url.searchParams.has('api') || request.headers.get('Accept')?.includes('application/json');\n\n  try {\n    const manifest = await getMarkdownManifest(ASSETS, request).catch(() => []);\n    const docExists = manifest.some(doc => doc.slug === validatedSlug);\n\n    if (!docExists) {\n      throw new Response('Document not found', { status: 404 });\n    }\n\n    const doc = await getMarkdownDocument(validatedSlug, ASSETS, request);\n\n    if (!doc) {\n      if (isApiCall) {\n        throw new Response('Document not found', { status: 404 });\n      }\n      // For UI requests, return manifest with loading state\n      return { manifest, selectedDoc: validatedSlug, document: null, loading: true };\n    }\n\n    const enhancedFrontmatter = {\n      ...doc.frontmatter,\n      formattedDate: doc.frontmatter.date ? new Date(doc.frontmatter.date).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' }) : undefined,\n    };\n\n    // If it's an API call, return the document data\n    if (isApiCall) {\n      return Response.json({ content: doc.content, frontmatter: enhancedFrontmatter, slug: validatedSlug });\n    }\n\n    const enhancedDoc = { ...doc, frontmatter: enhancedFrontmatter };\n\n    return { manifest, selectedDoc: validatedSlug, document: enhancedDoc };\n  } catch (error) {\n    // If it's a 404 error, re-throw it\n    if (error instanceof Response && error.status === 404) {\n      throw error;\n    }\n\n    // For other errors, return loading state for non-API calls\n    if (!isApiCall) {\n      const manifest = await getMarkdownManifest(ASSETS, request).catch(() => []);\n      return { manifest, selectedDoc: validatedSlug, document: null, loading: true };\n    }\n\n    // For API calls, throw the error\n    throw error;\n  }\n}\n"],"names":["doc"],"mappings":"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"}